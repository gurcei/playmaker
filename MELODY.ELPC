#output playmaker

' Keys:
' ----
'    Up arrow = Move to previous voice
'  Down arrow = Move to next voice
'  Left arrow = Move left within currrent voie string
' Right arrow = Move right within current voie string
'    INST/DEL = Delete char in current voice string
'       ESC,J = Move to start of current voice string
'       ESC,K = Move to end of current voice string
'      CTRL+W = Move forward one word in current voice string
'      CTRL+U = Move back one word in current voice string
'           < = Show previous song chunk
'           > = Show next song chunk
'           - = Decrease tempo
'           + = Increase tempo
'      MEGA+Q = Quit program / Exit Env Editor
'          F1 = Load
'          F3 = Save
'          F7 = Envelope editor
'          F8 = Filter editor

trap runstop_trapper

.declarations
'------------
#declare chunk_idx = 0
#declare chunk_cnt = 0
#define chunk_max = 20

#declare vidx, idx
#declare cursor_x = 0
#declare cursor_y = 0

#declare v$(5,chunk_max)

#declare key$
#declare valid$="cdefgab0123456789 #$.hiqrswotuxmpl"
#declare val$
#declare tmpo% = 12

#declare esc_flag% = 0

#struct ENVTYPE name$, attack, decay, sustain, release, waveform, pw

ENVTYPE envs(9) = [ {x5F}
  [ "Piano",       0,  9,  0,  0,  2, 1536 ], {x5F}
  [ "Accordion",  12,  0, 12,  0,  1,    0 ], {x5F}
  [ "Calliope",    0,  0, 15,  0,  0,    0 ], {x5F}
  [ "Drum",        0,  5,  5,  0,  3,    0 ], {x5F}
  [ "Flute",       9,  4,  4,  0,  0,    0 ], {x5F}
  [ "Guitar",      0,  9,  2,  1,  1,    0 ], {x5F}
  [ "Harpsicrd",   0,  9,  0,  0,  2,  512 ], {x5F}
  [ "Organ",       0,  9,  9,  0,  2, 2048 ], {x5F}
  [ "Trumpet",     8,  9,  4,  1,  2,  512 ], {x5F}
  [ "Xylophone",   0,  9,  0,  0,  0,    0 ]  {x5F}
]

#define DIR_NONE = 0
#define DIR_UP   = 1
#define DIR_DOWN = 2
#define DIR_OSC  = 3

#define F_OFF = 0
#define F_ON  = 1

#struct FILTTYPE name$, freq, lp, bp, hp, res, dir, min, sweep

FILTTYPE filt(10) = [ {x5F}
  [ "lowp_up",    1000, F_ON,  F_OFF, F_OFF, 15, DIR_UP,   100, 10 ], {x5F}
  [ "lowp_down",  1000, F_ON,  F_OFF, F_OFF, 15, DIR_DOWN, 100, 10 ], {x5F}
  [ "lowp_osc",   1000, F_ON,  F_OFF, F_OFF, 15, DIR_OSC,  100, 10 ], {x5F}
{x5F}
  [ "bandp_up",   1000, F_OFF, F_ON,  F_OFF, 15, DIR_UP,   100, 10 ], {x5F}
  [ "bandp_down", 1000, F_OFF, F_ON,  F_OFF, 15, DIR_DOWN, 100, 10 ], {x5F}
  [ "bandp_osc",  1000, F_OFF, F_ON,  F_OFF, 15, DIR_OSC,  100, 10 ], {x5F}
{x5F}
  [ "highp_up",   1000, F_OFF, F_OFF, F_ON,  15, DIR_UP,   100, 10 ], {x5F}
  [ "highp_down", 1000, F_OFF, F_OFF, F_ON,  15, DIR_DOWN, 100, 10 ], {x5F}
  [ "highp_osc",  1000, F_OFF, F_OFF, F_ON,  15, DIR_OSC,  100, 10 ], {x5F}
{x5F}
  [ "spare_1",    0,    F_OFF, F_OFF, F_OFF, 0,  DIR_NONE, 0,   0  ], {x5F}
  [ "spare_2",    0,    F_OFF, F_OFF, F_OFF, 0,  DIR_NONE, 0,   0  ], {x5F}
{x5F}
]

#declare row, col, srow, scol, a$, v, maxv, v$

#struct KEY_TYPE in$, out$

KEY_TYPE keys(11) = [ {x5F}
  [ "a", "c", ], {x5F}
  [ "w", "#c", ], {x5F}
  [ "s", "d", ], {x5F}
  [ "e", "#d", ], {x5F}
  [ "d", "e", ], {x5F}
  [ "f", "f", ], {x5F}
  [ "t", "#f", ], {x5F}
  [ "g", "g", ], {x5F}
  [ "y", "#g", ], {x5F}
  [ "h", "a", ], {x5F}
  [ "u", "#a", ], {x5F}
  [ "j", "b", ] {x5F}
]

#declare pstr$, k, delta

#declare wname$(4)
wname$(0) = "TRI"
wname$(1) = "SAW"
wname$(2) = "PULSE"
wname$(3) = "NOISE"
wname$(4) = "RING"

#declare filt_state_name$(2)
filt_state_name$(0) = "OFF"
filt_state_name$(1) = "ON"

#declare fpreset = 1

#declare fscol = 0, fsrow = 0, ffocus = 0, fsel = -1


.duration
'--------
#define DNAME = 0
#define DCHAR = 1
#define DKEY  = 2

#define D_WHOLE = 0
#define D_HALF = 1
#define D_QUARTER = 2
#define D_EIGHTH = 3
#define D_SIXTEENTH = 4

#declare sdur = 2
#declare dur$(5,2)
dur$(D_WHOLE, DNAME) = "whole"
dur$(D_WHOLE, DCHAR) = "w"
dur$(D_WHOLE, DKEY)  = "1"

dur$(D_HALF, DNAME) = "half"
dur$(D_HALF, DCHAR) = "h"
dur$(D_HALF, DKEY)  = "2"

dur$(D_QUARTER, DNAME) = "quarter"
dur$(D_QUARTER, DCHAR) = "q"
dur$(D_QUARTER, DKEY)  = "3"

dur$(D_EIGHTH, DNAME) = "eighth"
dur$(D_EIGHTH, DCHAR) = "i"
dur$(D_EIGHTH, DKEY)  = "4"

dur$(D_SIXTEENTH, DNAME) = "sixteenth"
dur$(D_SIXTEENTH, DCHAR) = "s"
dur$(D_SIXTEENTH, DKEY)  = "5"


.keys
'----
#define KEY_UP = "{x91}"
#define KEY_DOWN = "{x11}"
#define KEY_LEFT = "{x9D}"
#define KEY_RIGHT = "{x1D}"
#define KEY_DEL = "{x14}"
#define KEY_CTRL_W = "{x17}"
#define KEY_CTRL_U = "{x15}"
#define KEY_MEGA_Q = "«"
#define KEY_F1 = "{x85}"
#define KEY_F3 = "{x86}"
#define KEY_F4 = "{x8A}"
#define KEY_F7 = "{x88}"
#define KEY_F8 = "{x8C}"
#define KEY_RETURN = chr$(13)
#define KEY_ESCAPE = chr$(27)
#define KEY_SHIFT_RETURN = chr$(141)
#define KEY_SHIFT_PLUS = "Û"
#define KEY_SHIFT_MINUS = "Ý"
#define KEY_REV_ON = "{x12}"
#define KEY_REV_OFF = "{x92}"
#define KEY_TAB = chr$(9)

.init
'----
print "{x93}"
play : play ""

.main
'----
  key off
  gosub draw_editor_screen
  gosub user_input
  goto main

.draw_editor_screen
'------------------
  cursor 0,0:print "playmaker v0.01 - by  gurce isikyildiz"
  gosub draw_current_chunk
  return

.draw_current_chunk
'------------------
  print "{x93}"
  print "tempo:      {x9D}{x9D}{x9D}{x9D}{x9D}"; tmpo%
  print "chunk_idx:    {x9D}{x9D}{x9D}"; chunk_idx  
   
  for vidx=0 to 5
    if cursor_y <> vidx then begin
      cursor 0,5+vidx*2:print chr$(27);"q";"v";vidx;": ";v$(vidx,chunk_idx);
    bend:else begin
      cursor 0,5+vidx*2:print chr$(27);"q";"v";vidx;": ";
      for idx=1 to len(v$(vidx,chunk_idx))
        if cursor_x = idx-1 then begin
          print "{x12}";mid$(v$(vidx,chunk_idx),idx,1);"{x92}";
        bend:else begin
          print mid$(v$(vidx,chunk_idx),idx,1);
        bend
      next idx
      if len(v$(vidx,chunk_idx)) = 0 or cursor_x=len(v$(vidx,chunk_idx)) then print "{x12} {x92}";
    bend
  next vidx
  return

.check_valid_key
'---------------
  for idx=1 to len(valid$)
    val$=mid$(valid$,idx,1)
    if key$= val$ then begin
      if cursor_x < len(v$(cursor_y,chunk_idx)) then begin
        v$(cursor_y,chunk_idx) = left$(v$(cursor_y,chunk_idx),cursor_x) {x5F}
          + val$ + mid$(v$(cursor_y,chunk_idx),cursor_x+1)
        cursor_x=cursor_x+1
        return
      bend
      v$(cursor_y,chunk_idx)=v$(cursor_y,chunk_idx)+val$
      cursor_x=cursor_x+1
      return
    bend
  next idx
  return

.forward_word
'------------
  if cursor_x = len(v$(cursor_y,chunk_idx)) then return

  do while mid$(v$(cursor_y,chunk_idx),cursor_x+1,1) <> " "
    cursor_x=cursor_x+1
    if cursor_x = len(v$(cursor_y,chunk_idx)) then return
  loop
  do while mid$(v$(cursor_y,chunk_idx),cursor_x+1,1) = " "
    cursor_x=cursor_x+1
    if cursor_x = len(v$(cursor_y,chunk_idx)) then return
  loop

  return

.previous_word
'-------------
  if cursor_x = 0 then return
  if cursor_x = 1 then cursor_x = 0: return

  cursor_x = cursor_x - 1
  do while mid$(v$(cursor_y,chunk_idx),cursor_x+1,1) = " "
    cursor_x=cursor_x-1
    if cursor_x = 0 then return
  loop
  do while mid$(v$(cursor_y,chunk_idx),cursor_x+1,1) <> " "
    cursor_x=cursor_x-1
    if cursor_x = 0 then return
  loop
  cursor_x=cursor_x+1

  return

.load
'----
  input "load name: ";key$
  if key$="" then return

  dopen #2,(key$),r,u8

  print "load melody"
  ' load melody chunks
  ' ------------------
  for chunk_idx = 0 to chunk_max-1
    print "chunk_idx=";chunk_idx;", ";
    for vidx=0 to 5
      input #2,v$(vidx, chunk_idx)
    next vidx
  next chunk_idx

  print: print "get tempo"
  input #2,tmpo%
  
  print "load envelopes"
  ' load envelopes
  ' --------------
  for row = 0 to 9
    print "row=";row;", ";
    input #2, envs_name$(row)
    input #2, envs_attack(row)
    input #2, envs_decay(row)
    input #2, envs_sustain(row)
    input #2, envs_release(row)
    input #2, envs_waveform(row)
    input #2, envs_pw(row)
    gosub set_env
  next row
  print

  dclose #2

  get key a$

  chunk_idx = 0
  return

.save
'----
  input "save name: ";key$
  if key$="" then return
  
  delete (key$)
  dopen #2,(key$),w,u8

  ' save melody chunks
  ' ------------------
  for chunk_idx = 0 to chunk_max-1
    for vidx=0 to 5
      print #2,v$(vidx, chunk_idx)
    next vidx
  next chunk_idx
  print #2,tmpo%

  ' save envelopes
  ' --------------
  for row = 0 to 9
    print #2, envs_name$(row)
    print #2, envs_attack(row)
    print #2, envs_decay(row)
    print #2, envs_sustain(row)
    print #2, envs_release(row)
    print #2, envs_waveform(row)
    print #2, envs_pw(row)
  next row

  dclose #2

  chunk_idx = 0
  return

.save_as_text
'------------
  input "save (as text) name: ";key$
  if key$="" then return

  delete (key$)
    
  dopen #2,(key$),w,u8
  for chunk_idx = 0 to chunk_max-1
    for vidx=0 to 5
      print #2, "v";chr$(49+vidx);"$(";str$(chunk_idx);")=";
      print #2, chr$(34);v$(vidx, chunk_idx);chr$(34)
    next vidx  
    print #2, ""
  next chunk_idx
  dclose #2

  chunk_idx = 0
  return


.user_input
'----------
  getkey key$

  ' down arrow?
  if key$ = KEY_DOWN and cursor_y<5 then begin
    cursor_y = cursor_y + 1
    if cursor_x > len(v$(cursor_y,chunk_idx)) then cursor_x = {x5F}
      len(v$(cursor_y,chunk_idx))
  bend

  ' up arrow?
  if key$ = KEY_UP and cursor_y>0 then begin
    cursor_y = cursor_y - 1
    if cursor_x > len(v$(cursor_y,chunk_idx)) then {x5F}
      cursor_x = len(v$(cursor_y,chunk_idx))
  bend

  ' right arrow?
  if key$ = KEY_RIGHT and cursor_x < len(v$(cursor_y,chunk_idx)) then begin
    cursor_x=cursor_x+1
  bend

  ' left arrow?
  if key$ = KEY_LEFT and cursor_x > 0 then cursor_x=cursor_x-1

  ' backspace (inst/del)?
  if key$ = KEY_DEL and cursor_x > 0 then begin
    v$(cursor_y,chunk_idx)=left$(v$(cursor_y,chunk_idx),cursor_x-1) {x5F}
      + mid$(v$(cursor_y,chunk_idx),cursor_x+1)
    cursor_x=cursor_x-1
  bend

  if esc_flag% then begin
    esc_flag%=0
    if key$ = "j" then begin:cursor_x=0:bend
    if key$ = "k" then begin:cursor_x=len(v$(cursor_y,chunk_idx)):bend
    key$=""
  bend

  if key$ = KEY_ESCAPE then esc_flag%=abs(esc_flag%-1)

  ' ctrl-w = forward one word
  if key$ = KEY_CTRL_W then gosub forward_word

  ' ctrl-u = back one word
  if key$ = KEY_CTRL_U then gosub previous_word

  ' < / > = previous/next chunk
  if key$ = "<" and chunk_idx>0 then begin
    chunk_idx=chunk_idx-1
    cursor_x=0
  bend
  if key$ = ">" and chunk_idx<chunk_max then begin
    chunk_idx=chunk_idx+1
    cursor_x=0
  bend

  ' +/- = tempo change
  if key$="-" then tmpo%=tmpo%-1
  if key$="+" then tmpo%=tmpo%+1

  ' mega-q = exit
  if key$ = KEY_MEGA_Q then begin
    print "are you sure? (y/n)"
    get key a$
    if a$="y" then key on:end
  bend

  if key$ = KEY_F1 then gosub load
  if key$ = KEY_F3 then gosub save
  if key$ = KEY_F7 then gosub envelope_editor

  ' F4 = save as text
  if key$ = KEY_F4 then gosub save_as_text

  ' return=play row
  if key$ = KEY_RETURN then tempo tmpo% : play v$(cursor_y,chunk_idx)

  ' shift+return=play all channels
  if key$ = KEY_SHIFT_RETURN then begin
    tempo tmpo%
    play v$(0,chunk_idx), v$(1,chunk_idx), {x5F}
    v$(2,chunk_idx), v$(3,chunk_idx), v$(4,chunk_idx), {x5F}
    v$(5,chunk_idx)
  bend

  gosub check_valid_key
  return


.envelope_editor
'---------------
  do while 1
    gosub draw_table
    gosub get_user_input_for_table

    ' alt+q to exit
    if a$ = KEY_MEGA_Q then exit
  loop
  return



.draw_table
'----------
  print "{x93}env editor";KEY_TAB;dur$(sdur, DNAME)
  print "----------"
  print
  print "   NAME";KEY_TAB;KEY_TAB;"ATTACK";KEY_TAB;"DECAY";KEY_TAB;"SUSTAIN";KEY_TAB;"RELEASE";KEY_TAB;
  print "WAVEFRM";KEY_TAB;"PULSEWIDTH"

  for row = 0 to 9
    print row;" : ";
    col = 0 : v$ = envs_name$(row)
    gosub show_cell
    col = 1 : v = envs_attack(row)
    gosub show_cell
    col = 2 : v = envs_decay(row)
    gosub show_cell
    col = 3 : v = envs_sustain(row)
    gosub show_cell
    col = 4 : v = envs_release(row)
    gosub show_cell
    col = 5 : v = envs_waveform(row)
    gosub show_cell
    col = 6 : v = envs_pw(row)
    gosub show_cell
    print
  next row

  print
  print "filter editor"
  print "-------------";
  print KEY_TAB;"freq";KEY_TAB;"lp";KEY_TAB;"bp";KEY_TAB;"hp";KEY_TAB;"res";
  print KEY_TAB;"dir";KEY_TAB;"min";KEY_TAB;"sweep"

  for fpreset = 0 to 10
    gosub show_filter
  next fpreset

  return


.show_filter
'-----------
  if fsel = fpreset then print KEY_REV_ON;:else print KEY_REV_OFF;
  print filt_name$(fpreset);": ";KEY_TAB;
  if fsrow = fpreset and fscol = 0 then print KEY_REV_ON;:else print KEY_REV_OFF;
  print filt_freq(fpreset);KEY_TAB;
  if fsrow = fpreset and fscol = 1 then print KEY_REV_ON;:else print KEY_REV_OFF;
  print filt_state_name$(filt_lp(fpreset));KEY_TAB;
  if fsrow = fpreset and fscol = 2 then print KEY_REV_ON;:else print KEY_REV_OFF;
  print filt_state_name$(filt_bp(fpreset));KEY_TAB;
  if fsrow = fpreset and fscol = 3 then print KEY_REV_ON;:else print KEY_REV_OFF;
  print filt_state_name$(filt_hp(fpreset));KEY_TAB;
  if fsrow = fpreset and fscol = 4 then print KEY_REV_ON;:else print KEY_REV_OFF;
  print filt_res(fpreset);KEY_TAB;

  if fsrow = fpreset and fscol = 5 then print KEY_REV_ON;:else print KEY_REV_OFF;
  print filt_dir(fpreset);KEY_TAB;
  if fsrow = fpreset and fscol = 6 then print KEY_REV_ON;:else print KEY_REV_OFF;
  print filt_min(fpreset);KEY_TAB;
  if fsrow = fpreset and fscol = 7 then print KEY_REV_ON;:else print KEY_REV_OFF;
  print filt_sweep(fpreset);

  print KEY_REV_OFF
  return


.get_val
'-------
  if scol = 0 then v$ = envs_name$(srow)
  if scol = 1 then v = envs_attack(srow)
  if scol = 2 then v = envs_decay(srow)
  if scol = 3 then v = envs_sustain(srow)
  if scol = 4 then v = envs_release(srow)
  if scol = 5 then v = envs_waveform(srow)
  if scol = 6 then v = envs_pw(srow)

  return

.show_cell
'---------
  if srow=row and scol = col then print "{x12}";:else print "{x92}";

  if col = 0 then begin
    print v$;chr$(9);"{x92}";
    return
  bend

  if col = 5 then begin
    print wname$(v);chr$(9);"{x92}";
    return
  bend

  ' else
  print v;chr$(9);"{x92}";
  return


.get_user_input_for_table
'------------------------
  get key a$
  if a$ = KEY_LEFT and scol > 0 then scol = scol - 1
  if a$ = KEY_RIGHT and scol < 6 then scol = scol + 1
  if a$ = KEY_UP and srow > 0 then srow = srow - 1
  if a$ = KEY_DOWN and srow < 9 then srow = srow + 1
  if a$ = "+" or a$="=" then delta=1 : gosub incr_val
  if a$ = "-" then delta=1 : gosub decr_val
  if a$ = KEY_SHIFT_PLUS then delta=100 : gosub incr_val
  if a$ = KEY_SHIFT_MINUS then delta=100 : gosub decr_val
  if a$ = chr$(13) and scol = 0 then gosub change_env_name

  if a$ = KEY_TAB then ffocus = 1 : gosub get_user_input_for_filters

  gosub check_duration_change
  gosub check_piano_keys
  return

.get_user_input_for_filters
'--------------------------
  do while 1
    gosub draw_table

    get key a$

    if a$ = KEY_LEFT and fscol > 0 then fscol = fscol - 1
    if a$ = KEY_RIGHT and fscol < 7 then fscol = fscol + 1
    if a$ = KEY_UP and fsrow > 0 then fsrow = fsrow - 1
    if a$ = KEY_DOWN and fsrow < 10 then fsrow = fsrow + 1
    if a$ = "+" or a$="=" then delta=1 : gosub incr_fval
    if a$ = "-" then delta=1 : gosub decr_fval
    if a$ = KEY_SHIFT_PLUS then delta = 100 : gosub incr_fval
    if a$ = KEY_SHIFT_MINUS then delta = 100 : gosub decr_fval

    if a$ = KEY_RETURN then begin
      if fsel = fsrow then fsel = -1:else fsel = fsrow
      gosub apply_selected_filter
    bend

    if a$ = KEY_TAB or a$ = KEY_MEGA_Q then exit

    gosub check_duration_change
    gosub check_piano_keys
  loop
  ffocus = 0
  return


.check_duration_change
'---------------------
  for k = D_WHOLE to D_SIXTEENTH
    if a$ = dur$(k, DKEY) then sdur = k
  next k

  return


.apply_selected_filter
'---------------------
  filter 1, filt_freq(fsrow), filt_lp(fsrow), {x5F} 
         filt_bp(fsrow), filt_hp(fsrow), filt_res(fsrow)
  filter 2, filt_freq(fsrow), filt_lp(fsrow), {x5F} 
         filt_bp(fsrow), filt_hp(fsrow), filt_res(fsrow)

  return

.change_env_name
'---------------
  input "new name: ",v$
  if v$<>"" then envs_name$(srow) = v$
  return

.check_piano_keys
'----------------
  ' apply filter
  pstr$ = "x0"
  if fsel <> -1 then pstr$ = "x1"

  ' decide note length
  pstr$ = pstr$ + dur$(sdur, DCHAR)

  ' which note to play
  for k = 0 to 11
    if a$ = keys_in$(k) then pstr$ = pstr$ + keys_out$(k)
  next k

  if len(pstr$)>0 then begin
    play "o5t"+str$(srow)+pstr$
  bend

  return

.incr_val
'--------
  gosub get_val

  maxv = 15
  if scol = 5 then maxv = 4
  if scol = 6 then maxv = 4095
  v = v + delta
  if v > maxv then v = maxv
  gosub apply_val
  return


.decr_val
'--------
  gosub get_val

  v = v - delta
  if v < 0 then v = 0
  gosub apply_val
  return


.incr_fval
'---------
  if fscol = 0 then begin
    v = filt_freq(fsrow) + delta
    if v > 2047 then v = 2047
    filt_freq(fsrow) = v
  bend

  if fscol = 1 then filt_lp(fsrow) = 1
  if fscol = 2 then filt_bp(fsrow) = 1
  if fscol = 3 then filt_hp(fsrow) = 1

  if fscol = 4 then begin
    v = filt_res(fsrow) + delta
    if v > 15 then v = 15
    filt_res(fsrow) = v
  bend

  gosub apply_selected_filter
  return


.decr_fval
'---------
  if fscol = 0 then begin
    v = filt_freq(fsrow) - delta
    if v < 0 then v = 0
    filt_freq(fsrow) = v
  bend

  if fscol = 1 then filt_lp(fsrow) = 0
  if fscol = 2 then filt_bp(fsrow) = 0
  if fscol = 3 then filt_hp(fsrow) = 0

  if fscol = 4 then begin
    v = filt_res(fsrow) - delta
    if v < 0 then v = 0
    filt_res(fsrow) = v
  bend

  gosub apply_selected_filter
  return


.apply_val
'---------
  if scol=0 then envs_name$(srow) = v$
  if scol=1 then envs_attack(srow) = v
  if scol=2 then envs_decay(srow) = v
  if scol=3 then envs_sustain(srow) = v
  if scol=4 then envs_release(srow) = v
  if scol=5 then envs_waveform(srow) = v
  if scol=6 then envs_pw(srow) = v

  row = srow
  gosub set_env
  return


.set_env
'-------
  envelope row, envs_attack(row), envs_decay(row), envs_sustain(row), envs_release(row), envs_waveform(row), envs_pw(row)
  return

.runstop_trapper
'---------------
  if er=30 then resume  ' ignore run/stop
  trap
  print err$(er);" error"
  print " in line";el
  key on
  end
ÿ