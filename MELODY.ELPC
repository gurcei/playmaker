#output playmaker

' Keys:
' ----
'    Up arrow = Move to previous voice
'  Down arrow = Move to next voice
'  Left arrow = Move left within currrent voie string
' Right arrow = Move right within current voie string
'    INST/DEL = Delete char in current voice string
'       ESC,J = Move to start of current voice string
'       ESC,K = Move to end of current voice string
'      CTRL+W = Move forward one word in current voice string
'      CTRL+U = Move back one word in current voice string
'           < = Show previous song chunk
'           > = Show next song chunk
'           - = Decrease tempo
'           + = Increase tempo
'      MEGA+Q = Quit program / Exit Env Editor
'          F1 = Load
'          F3 = Save
'          F7 = Envelope editor
'          F8 = Filter editor

trap runstop_trapper

.declarations
'------------
#declare chunk_idx = 0
#declare chunk_cnt = 0
#define chunk_max = 20

#declare vidx, idx
#declare cursor_x = 0
#declare cursor_y = 0

#declare v$(5,chunk_max)

#declare key$
#declare valid$="cdefgab0123456789 #$.hiqrswotuxmpl"
#declare val$
#declare tmpo% = 12

#declare esc_flag% = 0

#struct ENVTYPE name$, attack, decay, sustain, release, waveform, pw

ENVTYPE envs(9) = [ {x5F}
  [ "Piano",       0,  9,  0,  0,  2, 1536 ], {x5F}
  [ "Accordion",  12,  0, 12,  0,  1,    0 ], {x5F}
  [ "Calliope",    0,  0, 15,  0,  0,    0 ], {x5F}
  [ "Drum",        0,  5,  5,  0,  3,    0 ], {x5F}
  [ "Flute",       9,  4,  4,  0,  0,    0 ], {x5F}
  [ "Guitar",      0,  9,  2,  1,  1,    0 ], {x5F}
  [ "Harpsicrd",   0,  9,  0,  0,  2,  512 ], {x5F}
  [ "Organ",       0,  9,  9,  0,  2, 2048 ], {x5F}
  [ "Trumpet",     8,  9,  4,  1,  2,  512 ], {x5F}
  [ "Xylophone",   0,  9,  0,  0,  0,    0 ]  {x5F}
]

#struct FILTTYPE name$, freq, lp, bp, hp, res

FILTTYPE filt(2) = [ {x5F}
  [ "Right", 0, 0, 0, 0, 0 ], {x5F}
  [ "Left",  0, 0, 0, 0, 0 ] {x5F}
]

#declare row, col, srow, scol, a$, v, maxv, v$

#struct KEY_TYPE in$, out$

KEY_TYPE keys(11) = [ {x5F}
  [ "a", "c", ], {x5F}
  [ "w", "#c", ], {x5F}
  [ "s", "d", ], {x5F}
  [ "e", "#d", ], {x5F}
  [ "d", "e", ], {x5F}
  [ "f", "f", ], {x5F}
  [ "t", "#f", ], {x5F}
  [ "g", "g", ], {x5F}
  [ "y", "#g", ], {x5F}
  [ "h", "a", ], {x5F}
  [ "u", "#a", ], {x5F}
  [ "j", "b", ] {x5F}
]

#declare pstr$, k, delta

#declare wname$(4)
wname$(0) = "TRI"
wname$(1) = "SAW"
wname$(2) = "PULSE"
wname$(3) = "NOISE"
wname$(4) = "RING"

#declare filt_state_name$(2)
filt_state_name$(0) = "OFF"
filt_state_name$(1) = "ON"

#declare sidgrp = 1

#define KEY_UP = "{x91}"
#define KEY_DOWN = "{x11}"
#define KEY_LEFT = "{x9D}"
#define KEY_RIGHT = "{x1D}"
#define KEY_DEL = "{x14}"
#define KEY_CTRL_W = "{x17}"
#define KEY_CTRL_U = "{x15}"
#define KEY_MEGA_Q = "«"
#define KEY_F1 = "{x85}"
#define KEY_F3 = "{x86}"
#define KEY_F4 = "{x8A}"
#define KEY_F7 = "{x88}"
#define KEY_F8 = "{x8C}"
#define KEY_RETURN = chr$(13)
#define KEY_ESCAPE = chr$(27)
#define KEY_SHIFT_RETURN = chr$(141)
#define KEY_SHIFT_PLUS = "Û"
#define KEY_SHIFT_MINUS = "Ý"
#define KEY_REV_ON = "{x12}"
#define KEY_REV_OFF = "{x92}"

.init
'----
print "{x93}"
play : play ""

.main
'----
  key off
  gosub draw_editor_screen
  gosub user_input
  goto main

.draw_editor_screen
'------------------
  cursor 0,0:print "playmaker v0.01 - by  gurce isikyildiz"
  gosub draw_current_chunk
  return

.draw_current_chunk
'------------------
  print "{x93}"
  print "tempo:      {x9D}{x9D}{x9D}{x9D}{x9D}"; tmpo%
  print "chunk_idx:    {x9D}{x9D}{x9D}"; chunk_idx  
   
  for vidx=0 to 5
    if cursor_y <> vidx then begin
      cursor 0,5+vidx*2:print chr$(27);"q";"v";vidx;": ";v$(vidx,chunk_idx);
    bend:else begin
      cursor 0,5+vidx*2:print chr$(27);"q";"v";vidx;": ";
      for idx=1 to len(v$(vidx,chunk_idx))
        if cursor_x = idx-1 then begin
          print "{x12}";mid$(v$(vidx,chunk_idx),idx,1);"{x92}";
        bend:else begin
          print mid$(v$(vidx,chunk_idx),idx,1);
        bend
      next idx
      if len(v$(vidx,chunk_idx)) = 0 or cursor_x=len(v$(vidx,chunk_idx)) then print "{x12} {x92}";
    bend
  next vidx
  return

.check_valid_key
'---------------
  for idx=1 to len(valid$)
    val$=mid$(valid$,idx,1)
    if key$= val$ then begin
      if cursor_x < len(v$(cursor_y,chunk_idx)) then begin
        v$(cursor_y,chunk_idx) = left$(v$(cursor_y,chunk_idx),cursor_x) {x5F}
          + val$ + mid$(v$(cursor_y,chunk_idx),cursor_x+1)
        cursor_x=cursor_x+1
        return
      bend
      v$(cursor_y,chunk_idx)=v$(cursor_y,chunk_idx)+val$
      cursor_x=cursor_x+1
      return
    bend
  next idx
  return

.forward_word
'------------
  if cursor_x = len(v$(cursor_y,chunk_idx)) then return

  do while mid$(v$(cursor_y,chunk_idx),cursor_x+1,1) <> " "
    cursor_x=cursor_x+1
    if cursor_x = len(v$(cursor_y,chunk_idx)) then return
  loop
  do while mid$(v$(cursor_y,chunk_idx),cursor_x+1,1) = " "
    cursor_x=cursor_x+1
    if cursor_x = len(v$(cursor_y,chunk_idx)) then return
  loop

  return

.previous_word
'-------------
  if cursor_x = 0 then return
  if cursor_x = 1 then cursor_x = 0: return

  cursor_x = cursor_x - 1
  do while mid$(v$(cursor_y,chunk_idx),cursor_x+1,1) = " "
    cursor_x=cursor_x-1
    if cursor_x = 0 then return
  loop
  do while mid$(v$(cursor_y,chunk_idx),cursor_x+1,1) <> " "
    cursor_x=cursor_x-1
    if cursor_x = 0 then return
  loop
  cursor_x=cursor_x+1

  return

.load
'----
  input "load name: ";key$
  if key$="" then return

  dopen #2,(key$),r,u8

  print "load melody"
  ' load melody chunks
  ' ------------------
  for chunk_idx = 0 to chunk_max-1
    print "chunk_idx=";chunk_idx;", ";
    for vidx=0 to 5
      input #2,v$(vidx, chunk_idx)
    next vidx
  next chunk_idx

  print: print "get tempo"
  input #2,tmpo%
  
  print "load envelopes"
  ' load envelopes
  ' --------------
  for row = 0 to 9
    print "row=";row;", ";
    input #2, envs_name$(row)
    input #2, envs_attack(row)
    input #2, envs_decay(row)
    input #2, envs_sustain(row)
    input #2, envs_release(row)
    input #2, envs_waveform(row)
    input #2, envs_pw(row)
    gosub set_env
  next row
  print

  dclose #2

  get key a$

  chunk_idx = 0
  return

.save
'----
  input "save name: ";key$
  if key$="" then return
  
  delete (key$)
  dopen #2,(key$),w,u8

  ' save melody chunks
  ' ------------------
  for chunk_idx = 0 to chunk_max-1
    for vidx=0 to 5
      print #2,v$(vidx, chunk_idx)
    next vidx
  next chunk_idx
  print #2,tmpo%

  ' save envelopes
  ' --------------
  for row = 0 to 9
    print #2, envs_name$(row)
    print #2, envs_attack(row)
    print #2, envs_decay(row)
    print #2, envs_sustain(row)
    print #2, envs_release(row)
    print #2, envs_waveform(row)
    print #2, envs_pw(row)
  next row

  dclose #2

  chunk_idx = 0
  return

.save_as_text
'------------
  input "save (as text) name: ";key$
  if key$="" then return

  delete (key$)
    
  dopen #2,(key$),w,u8
  for chunk_idx = 0 to chunk_max-1
    for vidx=0 to 5
      print #2, "v";chr$(49+vidx);"$(";str$(chunk_idx);")=";
      print #2, chr$(34);v$(vidx, chunk_idx);chr$(34)
    next vidx  
    print #2, ""
  next chunk_idx
  dclose #2

  chunk_idx = 0
  return


.user_input
'----------
  getkey key$

  ' down arrow?
  if key$ = KEY_DOWN and cursor_y<5 then begin
    cursor_y = cursor_y + 1
    if cursor_x > len(v$(cursor_y,chunk_idx)) then cursor_x = {x5F}
      len(v$(cursor_y,chunk_idx))
  bend

  ' up arrow?
  if key$ = KEY_UP and cursor_y>0 then begin
    cursor_y = cursor_y - 1
    if cursor_x > len(v$(cursor_y,chunk_idx)) then {x5F}
      cursor_x = len(v$(cursor_y,chunk_idx))
  bend

  ' right arrow?
  if key$ = KEY_RIGHT and cursor_x < len(v$(cursor_y,chunk_idx)) then begin
    cursor_x=cursor_x+1
  bend

  ' left arrow?
  if key$ = KEY_LEFT and cursor_x > 0 then cursor_x=cursor_x-1

  ' backspace (inst/del)?
  if key$ = KEY_DEL and cursor_x > 0 then begin
    v$(cursor_y,chunk_idx)=left$(v$(cursor_y,chunk_idx),cursor_x-1) {x5F}
      + mid$(v$(cursor_y,chunk_idx),cursor_x+1)
    cursor_x=cursor_x-1
  bend

  if esc_flag% then begin
    esc_flag%=0
    if key$ = "j" then begin:cursor_x=0:bend
    if key$ = "k" then begin:cursor_x=len(v$(cursor_y,chunk_idx)):bend
    key$=""
  bend

  if key$ = KEY_ESCAPE then esc_flag%=abs(esc_flag%-1)

  ' ctrl-w = forward one word
  if key$ = KEY_CTRL_W then gosub forward_word

  ' ctrl-u = back one word
  if key$ = KEY_CTRL_U then gosub previous_word

  ' < / > = previous/next chunk
  if key$ = "<" and chunk_idx>0 then begin
    chunk_idx=chunk_idx-1
    cursor_x=0
  bend
  if key$ = ">" and chunk_idx<chunk_max then begin
    chunk_idx=chunk_idx+1
    cursor_x=0
  bend

  ' +/- = tempo change
  if key$="-" then tmpo%=tmpo%-1
  if key$="+" then tmpo%=tmpo%+1

  ' mega-q = exit
  if key$ = KEY_MEGA_Q then begin
    print "are you sure? (y/n)"
    get key a$
    if a$="y" then key on:end
  bend

  if key$ = KEY_F1 then gosub load
  if key$ = KEY_F3 then gosub save
  if key$ = KEY_F7 then gosub envelope_editor

  ' F4 = save as text
  if key$ = KEY_F4 then gosub save_as_text

  ' return=play row
  if key$ = KEY_RETURN then tempo tmpo% : play v$(cursor_y,chunk_idx)

  ' shift+return=play all channels
  if key$ = KEY_SHIFT_RETURN then begin
    tempo tmpo%
    play v$(0,chunk_idx), v$(1,chunk_idx), {x5F}
    v$(2,chunk_idx), v$(3,chunk_idx), v$(4,chunk_idx), {x5F}
    v$(5,chunk_idx)
  bend

  gosub check_valid_key
  return


.envelope_editor
'---------------
  do while 1
    gosub draw_table
    gosub get_user_input_for_table

    ' alt+q to exit
    if a$ = KEY_MEGA_Q then exit
  loop
  return

.draw_table
'----------
  print "{x93}env editor"
  print " ----------"
  print
  print "   NAME";chr$(9);chr$(9);"ATTACK";chr$(9);"DECAY";chr$(9);"SUSTAIN";chr$(9);"RELEASE";chr$(9);
  print "WAVEFRM";chr$(9);"PULSEWIDTH"

  for row = 0 to 9
    print row;" : ";
    col = 0 : v$ = envs_name$(row)
    gosub show_cell
    col = 1 : v = envs_attack(row)
    gosub show_cell
    col = 2 : v = envs_decay(row)
    gosub show_cell
    col = 3 : v = envs_sustain(row)
    gosub show_cell
    col = 4 : v = envs_release(row)
    gosub show_cell
    col = 5 : v = envs_waveform(row)
    gosub show_cell
    col = 6 : v = envs_pw(row)
    gosub show_cell
  next row

  print
  print "filter editor"
  print "-------------"
  sidgrp = 1 : gosub show_filter
  sidgrp = 2 : gosub show_filter

  return


.show_filter
'-----------
  print
  print "show_filter"
  print "-----------";chr$(3);"freq";chr$(3);"lp";chr$(3);"bp";chr$(3);"hp";chr$(3);"res"
  print "SIDS ";filt_name$(sidgrp);": ";chr$(3);
  print filt_freq(sidgrp);chr$(3);
  print filt_state_name$(filt_lp(sidgrp));chr$(3);
  print filt_state_name$(filt_bp(sidgrp));chr$(3);
  print filt_state_name$(filt_hp(sidgrp));chr$(3);
  print filt_res(sidgrp)
  return


.get_val
'-------
  if scol = 0 then v$ = envs_name$(srow)
  if scol = 1 then v = envs_attack(srow)
  if scol = 2 then v = envs_decay(srow)
  if scol = 3 then v = envs_sustain(srow)
  if scol = 4 then v = envs_release(srow)
  if scol = 5 then v = envs_waveform(srow)
  if scol = 6 then v = envs_pw(srow)

  return

.show_cell
'---------
  if srow=row and scol = col then print "{x12}";:else print "{x92}";

  if col = 0 then begin
    print v$;chr$(9);"{x92}";
    return
  bend

  if col = 5 then begin
    print wname$(v);chr$(9);"{x92}";
    return
  bend

  ' else
  print v;chr$(9);"{x92}";
  return


.get_user_input_for_table
'------------------------
  get key a$
  if a$ = KEY_LEFT and scol > 0 then scol = scol - 1
  if a$ = KEY_RIGHT and scol < 6 then scol = scol + 1
  if a$ = KEY_UP and srow > 0 then srow = srow - 1
  if a$ = KEY_DOWN and srow < 9 then srow = srow + 1
  if a$ = "+" then delta=1 : gosub incr_val
  if a$ = "-" then delta=1 : gosub decr_val
  if a$ = KEY_SHIFT_PLUS then delta=100 : gosub incr_val
  if a$ = KEY_SHIFT_MINUS then delta=100 : gosub decr_val
  if a$ = chr$(13) and scol = 0 then gosub change_env_name

  gosub check_piano_keys
  return

.change_env_name
'---------------
  input "new name: ",v$
  if v$<>"" then envs_name$(srow) = v$
  return

.check_piano_keys
'----------------
  pstr$ = ""
  for k = 0 to 11
    if a$ = keys_in$(k) then pstr$ = keys_out$(k)
  next k

  if len(pstr$)>0 then begin
    play "o5qt"+str$(srow)+pstr$
  bend

  return

.incr_val
'--------
  gosub get_val

  maxv = 15
  if scol = 5 then maxv = 4
  if scol = 6 then maxv = 4095
  v = v + delta
  if v > maxv then v = maxv
  gosub apply_val
  return

.decr_val
'--------
  gosub get_val

  v = v - delta
  if v < 0 then v = 0
  gosub apply_val
  return

.apply_val
'---------
  if scol=0 then envs_name$(srow) = v$
  if scol=1 then envs_attack(srow) = v
  if scol=2 then envs_decay(srow) = v
  if scol=3 then envs_sustain(srow) = v
  if scol=4 then envs_release(srow) = v
  if scol=5 then envs_waveform(srow) = v
  if scol=6 then envs_pw(srow) = v

  row = srow
  gosub set_env
  return


.set_env
'-------
  envelope row, envs_attack(row), envs_decay(row), envs_sustain(row), envs_release(row), envs_waveform(row), envs_pw(row)
  return

.runstop_trapper
'---------------
  if er=30 then resume  ' ignore run/stop
  trap
  print err$(er);" error"
  print " in line";el
  key on
  end
ÿ